-- Tables:

CREATE TABLE CITIES (
	CITY_id				NUMBER (3) NOT NULL,
	CITY_name			VARCHAR2 (100 CHAR) NOT NULL,
	
	CONSTRAINT CITIES_PK PRIMARY KEY (CITY_id)
);

CREATE TABLE ROOM_SIZES (
	RSZ_type			VARCHAR2 (10 BYTE) NOT NULL,
	RSZ_seat_min		NUMBER (3) NOT NULL,
	RSZ_seat_max		NUMBER (3) NOT NULL,
	
	CONSTRAINT ROOM_SIZES_PK PRIMARY KEY (RSZ_type),
    
    -- check constraints
    CONSTRAINT ROOM_SIZES_CHK CHECK (RSZ_seat_min > 0 AND RSZ_seat_max >= RSZ_seat_min)
);

CREATE TABLE ROOM_SETTINGS (
	RS_id				NUMBER (2) NOT NULL,
	RS_type				VARCHAR2 (50 CHAR) UNIQUE NOT NULL,
	
	CONSTRAINT ROOM_SETTINGS_PK PRIMARY KEY (RS_id)
);

CREATE TABLE DEGREES (
	DEG_id				NUMBER (2) NOT NULL,
	DEG_name			VARCHAR2 (50) NOT NULL,
	
	CONSTRAINT DEGREES_PK PRIMARY KEY (DEG_id)
);

CREATE TABLE COMPANIES (
	COM_id				NUMBER (4) NOT NULL,
	COM_name			VARCHAR2 (100 BYTE) NOT NULL,
	COM_address			VARCHAR2 (100 CHAR) NOT NULL,
	COM_tel				VARCHAR2 (20 BYTE) UNIQUE NOT NULL,
	COM_email			VARCHAR2 (50 BYTE) UNIQUE NOT NULL,
	
	CONSTRAINT COMPANIES_PK PRIMARY KEY (COM_id),
    
    -- check constraints
    CONSTRAINT COMPANIES_TEL_CHK   CHECK (REGEXP_LIKE(COM_tel, '^[[:digit:]]{9}$')),  -- 9 digits
    CONSTRAINT COMPANIES_EMAIL_CHK CHECK (COM_email LIKE '%@%')
);

CREATE TABLE PERSONS (
	P_id				NUMBER NOT NULL,
	P_name				VARCHAR2 (100 CHAR) NOT NULL,
	P_surname			VARCHAR2 (100 CHAR) NOT NULL,
	P_tel				VARCHAR2 (20 BYTE) UNIQUE NOT NULL,
	P_email				VARCHAR2 (50 BYTE) UNIQUE NOT NULL,
	
	CONSTRAINT PERSONS_PK PRIMARY KEY (P_id),
    
    -- check constraints
    CONSTRAINT PERSONS_TEL_CHK   CHECK (REGEXP_LIKE(P_tel, '^[[:digit:]]{9}$')),  -- 9 digits
    CONSTRAINT PERSONS_EMAIL_CHK CHECK (P_email LIKE '%@%')                       -- any string containing the '@' character
);

CREATE TABLE UNIVERSITIES (
	UNI_id				NUMBER (3) NOT NULL,
	UNI_name			VARCHAR2 (100 CHAR) NOT NULL,
	UNI_city			NUMBER (3) NOT NULL,
	
	CONSTRAINT UNIVERSITIES_PK PRIMARY KEY (UNI_id),
	CONSTRAINT UNIVERSITIES_CITIES_FK FOREIGN KEY (UNI_city) REFERENCES CITIES (CITY_id) ON DELETE SET NULL -- [?] CASCADE (attrib is NOT NULL)
);

CREATE TABLE LOCAL_COMMITTEES (
	LC_id				NUMBER (4) NOT NULL,
	LC_tel				VARCHAR2 (20 BYTE) NOT NULL,
	LC_email			VARCHAR2 (50 BYTE) NOT NULL,
	LC_uni				NUMBER (3) NOT NULL,
	
	CONSTRAINT LOCAL_COMMITTEES_PK PRIMARY KEY (LC_id),
	CONSTRAINT LOCAL_COMMITTEES_UNI_FK FOREIGN KEY (LC_uni) REFERENCES UNIVERSITIES (UNI_id) ON DELETE CASCADE,
    
    -- check constraints
    CONSTRAINT LOCAL_COMMITTEES_TEL_CHK   CHECK (REGEXP_LIKE(LC_tel, '^[[:digit:]]{9}$')),  -- 9 digits
    CONSTRAINT LOCAL_COMMITTEES_EMAIL_CHK CHECK (LC_email LIKE '%@%')
);

CREATE TABLE STUDENTS (
	STUD_id				NUMBER NOT NULL,
	STUD_faculty		VARCHAR2 (100 CHAR) NOT NULL,
	STUD_year			NUMBER (2) NOT NULL,
	STUD_major			VARCHAR2 (100 CHAR) NOT NULL,
	STUD_book_num		VARCHAR2 (20 BYTE) NOT NULL,
	STUD_specialization	VARCHAR2 (200),
	STUD_uni			NUMBER (3) NOT NULL,
	
	CONSTRAINT STUDENTS_PK PRIMARY KEY (STUD_id),
	-- ISA
	CONSTRAINT STUDENTS_PERSONS_FK FOREIGN KEY (STUD_id) REFERENCES PERSONS (P_id) ON DELETE CASCADE,
	
	CONSTRAINT STUDENTS_UNIVERSITIES_FK FOREIGN KEY (STUD_uni) REFERENCES UNIVERSITIES (UNI_id) ON DELETE SET NULL,
    
    CONSTRAINT STUDENTS_UNI_BOOK_UNIQUE UNIQUE (STUD_uni, STUD_book_num),
    
    -- check constraints
    CONSTRAINT STUDENTS_YEAR_CHK      CHECK (STUD_year > 0),
    CONSTRAINT STUDENTS_BOOK_NUM_CHK  CHECK (REGEXP_LIKE(STUD_book_num, '^[[:digit:][:alpha:]]{6}$'))  -- 6 digits and/or letters
);

CREATE TABLE SPEAKERS (
	SPK_id				NUMBER NOT NULL,
	SPK_degree			NUMBER (2) NOT NULL,
	SPK_years_of_exp	NUMBER (3),
	SPK_graduated		NUMBER (4),
	SPK_company			NUMBER (4) NOT NULL,
	
	CONSTRAINT SPEAKERS_PK PRIMARY KEY (SPK_id),
	-- ISA
	CONSTRAINT SPEAKERS_PERSONS_FK FOREIGN KEY (SPK_id) REFERENCES PERSONS (P_id) ON DELETE CASCADE,
	
	CONSTRAINT SPEAKERS_COMPANIES_FK FOREIGN KEY (SPK_company) REFERENCES COMPANIES (COM_id) ON DELETE SET NULL, -- [?] CASCADE (attrib is NOT NULL)
	CONSTRAINT SPEAKERS_DEGREES_FK FOREIGN KEY (SPK_degree) REFERENCES DEGREES (DEG_id) ON DELETE SET NULL,
	CONSTRAINT SPEAKERS_UNIVERSITIES_FK FOREIGN KEY (SPK_graduated) REFERENCES UNIVERSITIES (UNI_id) ON DELETE SET NULL,
    
    -- check constraints
    CONSTRAINT SPEAKERS_EXP_YEARS_CHK CHECK (SPK_years_of_exp >= 0)
);

CREATE TABLE CONTACTS (
	LC_id				NUMBER (4) NOT NULL,
	COM_id				NUMBER (4) NOT NULL,
	
	CONSTRAINT CONTACTS_PK PRIMARY KEY (LC_id, COM_id),
	CONSTRAINT CONTACTS_LC_FK FOREIGN KEY (LC_id) REFERENCES LOCAL_COMMITTEES (LC_id) ON DELETE CASCADE,
	CONSTRAINT CONTACTS_COMPANIES_FK FOREIGN KEY (COM_id) REFERENCES COMPANIES (COM_id) ON DELETE CASCADE
);

CREATE TABLE WORKSHOPS (
	WS_id				NUMBER (4) NOT NULL,
	WS_name				VARCHAR2 (200 CHAR) NOT NULL,
	WS_date				DATE NOT NULL,
	WS_group_qty		NUMBER (2),
	WS_room_setting		NUMBER (2),
	WS_organizer		NUMBER (4) NOT NULL,
	WS_room_type		VARCHAR2 (10 BYTE) NOT NULL,
	
	CONSTRAINT WORKSHOPS_PK PRIMARY KEY (WS_id),
	CONSTRAINT WORKSHOPS_LC_FK FOREIGN KEY (WS_organizer) REFERENCES LOCAL_COMMITTEES (LC_id) ON DELETE CASCADE,
	CONSTRAINT WORKSHOPS_RS_FK FOREIGN KEY (WS_room_setting) REFERENCES ROOM_SETTINGS (RS_id) ON DELETE SET NULL,
	CONSTRAINT WORKSHOPS_RSZ_FK FOREIGN KEY (WS_room_type) REFERENCES ROOM_SIZES (RSZ_type) ON DELETE SET NULL,
    
    -- check constraints
    CONSTRAINT WS_GROUP_QTY_CHK CHECK (WS_group_qty >= 0)
);

CREATE TABLE LEADS (
	SPK_id				NUMBER NOT NULL,
	WS_id				NUMBER (4) NOT NULL,
	
	CONSTRAINT LEADS_PK PRIMARY KEY (SPK_id, WS_id),
	CONSTRAINT LEADS_SPEAKERS_FK FOREIGN KEY (SPK_id) REFERENCES SPEAKERS (SPK_id) ON DELETE CASCADE,
	CONSTRAINT LEADS_WORKSHOPS_FK FOREIGN KEY (WS_id) REFERENCES WORKSHOPS (WS_id) ON DELETE CASCADE
);

CREATE TABLE ATTENDS (
	STUD_id				NUMBER NOT NULL,
	WS_id				NUMBER (4) NOT NULL,
	
	CONSTRAINT ATTENDS_PK PRIMARY KEY (STUD_id, WS_id),
	CONSTRAINT ATTENDS_STUDENTS_FK FOREIGN KEY (STUD_id) REFERENCES STUDENTS (STUD_id) ON DELETE CASCADE,
	CONSTRAINT ATTENDS_WORKSHOPS_FK FOREIGN KEY (WS_id) REFERENCES WORKSHOPS (WS_id) ON DELETE CASCADE
);


-- Sequences:

CREATE SEQUENCE PERSONS_SEQ
	START WITH 1 
	INCREMENT BY 1;

CREATE SEQUENCE WORKSHOPS_SEQ
	START WITH 1
	INCREMENT BY 1;

	
-- Views:

CREATE OR REPLACE VIEW V_STUDENTS_DATA AS
SELECT pers.P_NAME AS "Name", pers.P_SURNAME AS "Surname", uni.UNI_NAME AS "University", 
stud.STUD_FACULTY AS "Faculty", stud.STUD_MAJOR AS "Major", stud.STUD_YEAR AS "Year" FROM STUDENTS stud
LEFT JOIN PERSONS pers ON pers.P_ID = stud.STUD_ID
LEFT JOIN UNIVERSITIES uni ON uni.UNI_ID = stud.STUD_UNI;

CREATE OR REPLACE VIEW V_EXPERIENCED_WORKSHOP_LEADERS AS
SELECT ws.WS_NAME AS "Workshop", pers.P_NAME AS "Name", pers.P_SURNAME AS "Surname", 
deg.DEG_NAME AS "Degree", uni.UNI_NAME AS "Graduated", cmp.COM_NAME AS "Company" FROM SPEAKERS spk
LEFT JOIN PERSONS pers ON pers.P_ID = spk.SPK_ID
LEFT JOIN DEGREES deg ON deg.DEG_ID = spk.SPK_DEGREE
LEFT JOIN COMPANIES cmp ON cmp.COM_ID = spk.SPK_COMPANY
LEFT JOIN UNIVERSITIES uni ON uni.UNI_ID = spk.SPK_GRADUATED
LEFT JOIN LEADS ls ON ls.SPK_ID = spk.SPK_ID
LEFT JOIN WORKSHOPS ws ON ws.WS_ID = ls.WS_ID
WHERE spk.SPK_YEARS_OF_EXP > '5';

CREATE OR REPLACE VIEW V_ROOM_LIMITS AS
SELECT ws.WS_NAME AS "Workshop", ws.WS_GROUP_QTY AS "Expected group quantity", 
rsz.RSZ_SEAT_MIN AS "Minimum seats", rsz.RSZ_SEAT_MAX AS "Maximum seats" FROM WORKSHOPS ws
LEFT JOIN ROOM_SIZES rsz ON rsz.RSZ_TYPE = ws.WS_ROOM_TYPE;


-- Triggers (autonumber):

CREATE OR REPLACE TRIGGER PERSONS_AUTONR_TRG
  BEFORE INSERT ON PERSONS
  FOR EACH ROW
BEGIN
  IF :new.P_id IS NULL THEN
    :new.P_id := PERSONS_SEQ.nextval;
  END IF;
END PERSONS_AUTONR_TRG;
/

CREATE OR REPLACE TRIGGER WORKSHOPS_AUTONR_TRG
  BEFORE INSERT ON WORKSHOPS
  FOR EACH ROW
BEGIN
  IF :new.WS_id IS NULL THEN
    :new.WS_id := WORKSHOPS_SEQ.nextval;
  END IF;
END WORKSHOPS_AUTONR_TRG;
/

CREATE OR REPLACE PROCEDURE CONVERT_TEL (
    tel IN OUT VARCHAR2
)
IS
  wrong_tel_format EXCEPTION;
BEGIN
  IF REGEXP_LIKE(tel, '^\d{3}[- ]\d{3}[- ]\d{3}$') THEN
    tel := REGEXP_REPLACE(tel, '[- ]'); -- remove all matched patterns  
    -- the first position in the string is 1 (not 0)
    dbms_output.put_line('CONVERT_TEL: tel converted to: ' || tel || '.');
    
  ELSIF REGEXP_LIKE(tel, '^\d{9}$') THEN
    NULL;   -- do not change the tel number
  ELSE
    RAISE wrong_tel_format;
  END IF;
  
EXCEPTION
  WHEN wrong_tel_format THEN
    dbms_output.put_line('Wrong tel number format. Expected formats are:
      ddddddddd
      ddd-ddd-ddd
      ddd ddd ddd');
    -- ROLLBACK WORK;
    RAISE;
END CONVERT_TEL;
/

CREATE OR REPLACE TRIGGER PERSONS_TEL_CONVERT_TRG
  BEFORE INSERT OR UPDATE OF P_tel ON PERSONS
  FOR EACH ROW
BEGIN
  CONVERT_TEL(:new.P_tel);

  -- do not catch exception
  -- no inset or update will succeed if the passed tel has wrong format
  
  -- TODO catch user-defined exception and raise application error ?
END PERSONS_TEL_CONVERT_TRG;
/

CREATE OR REPLACE TRIGGER COMPANIES_TEL_CONVERT_TRG
  BEFORE INSERT OR UPDATE OF COM_tel ON COMPANIES
  FOR EACH ROW
BEGIN
  CONVERT_TEL(:new.COM_tel);

  -- do not catch exception
  -- no inset or update will succeed if the passed tel has wrong format
END COMPANIES_TEL_CONVERT_TRG;
/

CREATE OR REPLACE TRIGGER LC_TEL_CONVERT_TRG
  BEFORE INSERT OR UPDATE OF LC_tel ON LOCAL_COMMITTEES
  FOR EACH ROW
BEGIN
  CONVERT_TEL(:new.LC_tel);

  -- do not catch exception
  -- no inset or update will succeed if the passed tel has wrong format
END LC_TEL_CONVERT_TRG;
/
